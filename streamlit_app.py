# -*- coding: utf-8 -*-
"""streamlit_app_2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1NRUFzO_H-JlVrq10BcbBcT32WMcWdHhG
"""

import streamlit as st
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import mplstereonet
from itertools import combinations

# --- Core functionality ---
def calculate_planes(points, separation_limit):
    pts = np.asarray(points, dtype=float)
    n = len(pts)
    # build neighbor sets
    neighbors = [set() for _ in range(n)]
    for i in range(n):
        for j in range(i+1, n):
            if np.linalg.norm(pts[i] - pts[j]) <= separation_limit:
                neighbors[i].add(j)
                neighbors[j].add(i)
    planes = []
    colinear = []
    for i in range(n):
        for j in neighbors[i]:
            for k in neighbors[j]:
                if k <= j or k not in neighbors[i]:
                    continue
                p1, p2, p3 = pts[i], pts[j], pts[k]
                v1 = p2 - p1
                v2 = p3 - p1
                normal = np.cross(v1, v2)
                norm = np.linalg.norm(normal)
                if norm == 0:
                    colinear.append((p1, p2, p3))
                else:
                    planes.append(normal / norm)
    return np.array(planes), colinear


def extract_strike_dip(planes):
    strikes, dips = [], []
    for nx, ny, nz in planes:
        if nz < 0:
            nx, ny, nz = -nx, -ny, -nz
        dip = np.degrees(np.arctan2(np.hypot(nx, ny), nz))
        dipdir = np.degrees(np.arctan2(nx, ny)) % 360.0
        strike = (dipdir - 90.0) % 360.0
        strikes.append(strike)
        dips.append(dip)
    return np.array(strikes), np.array(dips)


def plot_stereonets(strikes, dips, strikes_sub, dips_sub, method, sigma, max_plot, output_name):
    # Create figure with two stereonets
    fig, (ax1, ax2) = plt.subplots(
        2, 1, figsize=(8, 12),
        subplot_kw={'projection': 'stereonet'}
    )
    # 1) Individual poles
    ax1.pole(strikes_sub, dips_sub, 'k.', ms=2)
    ax1.set_title('Individual poles')
    ax1.grid(True)
    # 2) Density contour
    dens = ax2.density_contourf(
        strikes, dips,
        measurement='poles',
        method=method,
        sigma=sigma
    )
    fig.colorbar(dens, ax=ax2, label='Pole density', pad=0.12)
    ax2.set_title('Density contour')
    ax2.grid(True)
    # Recalculate density grid to find max-density pole
    dgx, dgy, dgz = mplstereonet.density_grid(
        strikes, dips,
        measurement='poles',
        method=method,
        sigma=sigma
    )
    i_max, j_max = np.unravel_index(np.nanargmax(dgz), dgz.shape)
    max_rad_x = dgx[i_max, j_max]
    max_rad_y = dgy[i_max, j_max]
    max_strike, max_dip = mplstereonet.geographic2pole(max_rad_x, max_rad_y)
    # Mark max-density pole on both plots
    for ax in (ax1, ax2):
        ax.pole(max_strike, max_dip, 'ro', ms=5)
        ax.plane(max_strike, max_dip, 'r')
    st.write(f"Max-density pole: strike={max_strike:.1f}, dip={max_dip:.1f}")
    # Save if desired
    if output_name:
        fig.savefig(output_name, dpi=300)
        st.success(f"Saved figure to {output_name}")
    st.pyplot(fig)

# --- Streamlit UI ---
st.title('Structural Trend Application')

uploaded = st.file_uploader('Upload CSV file', type='csv')
if uploaded is not None:
    skip_rows = st.number_input('Header rows to skip', min_value=0, step=1, value=0)
    try:
        df = pd.read_csv(uploaded, skiprows=int(skip_rows))
    except Exception as e:
        st.error(f"Error reading CSV: {e}")
        st.stop()
    if df.shape[1] < 3:
        st.error("Data must have at least 3 columns.")
        st.stop()
    cols = list(df.columns)
    x_col = st.selectbox('X-coordinate column', cols, index=0)
    y_col = st.selectbox('Y-coordinate column', cols, index=1 if len(cols)>1 else 0)
    z_col = st.selectbox('Z-coordinate column', cols, index=2 if len(cols)>2 else 0)
    separation_limit = st.number_input('Separation-distance limit', min_value=0.0, step=0.1, value=1.0)
    if st.button('Calculate planes'):
        points = df[[x_col, y_col, z_col]].values
        planes, colinear = calculate_planes(points, separation_limit)
        st.session_state['planes'] = planes
        st.session_state['colinear'] = colinear
    if 'planes' in st.session_state:
        planes = st.session_state['planes']
        colinear = st.session_state['colinear']
        st.write(f"Valid planes: {len(planes)}, invalid/colinear: {len(colinear)}")
        strikes_all, dips_all = extract_strike_dip(planes)
        use_all = st.radio('Use all planes?', ('Yes', 'No'))
        if use_all == 'Yes':
            strikes_sub, dips_sub = strikes_all, dips_all
        else:
            sample_method = st.selectbox('Subset method', ('Random subset', 'Slice'))
            if sample_method == 'Random subset':
                size = st.number_input('Subset size', min_value=1, max_value=len(strikes_all), value=min(200, len(strikes_all)))
                idx = np.random.choice(len(strikes_all), size, replace=False)
                strikes_sub, dips_sub = strikes_all[idx], dips_all[idx]
            else:
                start_idx = st.number_input('Slice start index', min_value=0, max_value=len(strikes_all)-1, value=0)
                end_idx = st.number_input('Slice end index', min_value=1, max_value=len(strikes_all), value=len(strikes_all))
                strikes_sub, dips_sub = strikes_all[start_idx:end_idx], dips_all[start_idx:end_idx]
        method = st.selectbox('Density method', ('exponential_kamb', 'linear_kamb', 'kamb', 'kernel', 'counts'))
        if method in ('exponential_kamb', 'linear_kamb', 'kamb'):
            sigma = st.number_input('Sigma for Kamb', min_value=0.1, step=0.1, value=3.0)
        else:
            sigma = None
        max_plot = st.number_input('Max # poles to plot', min_value=1, step=1, value=2000)
        output_name = st.text_input('Output image filename (jpg/png)', '')
        if st.button('Generate stereonets'):
            plot_stereonets(strikes_all, dips_all, strikes_sub, dips_sub, method, sigma, max_plot, output_name)
