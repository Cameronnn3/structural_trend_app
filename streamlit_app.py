# -*- coding: utf-8 -*-
"""streamlit_app_2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1NRUFzO_H-JlVrq10BcbBcT32WMcWdHhG
"""

import streamlit as st
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import mplstereonet
from itertools import combinations

# --- Core functionality ---
def calculate_planes(points, separation_limit):
    pts = np.asarray(points, dtype=float)
    n = len(pts)
    # build neighbor sets
    neighbors = [set() for _ in range(n)]
    for i in range(n):
        for j in range(i+1, n):
            if np.linalg.norm(pts[i] - pts[j]) <= separation_limit:
                neighbors[i].add(j)
                neighbors[j].add(i)
    planes = []
    colinear = []
    for i in range(n):
        for j in neighbors[i]:
            for k in neighbors[j]:
                if k <= j or k not in neighbors[i]:
                    continue
                p1, p2, p3 = pts[i], pts[j], pts[k]
                v1 = p2 - p1
                v2 = p3 - p1
                normal = np.cross(v1, v2)
                norm = np.linalg.norm(normal)
                if norm == 0:
                    colinear.append((p1, p2, p3))
                else:
                    planes.append(normal / norm)
    return np.array(planes), colinear


def extract_strike_dip(planes):
    strikes, dips = [], []
    for nx, ny, nz in planes:
        if nz < 0:
            nx, ny, nz = -nx, -ny, -nz
        dip = np.degrees(np.arctan2(np.hypot(nx, ny), nz))
        dipdir = np.degrees(np.arctan2(nx, ny)) % 360.0
        strike = (dipdir - 90.0) % 360.0
        strikes.append(strike)
        dips.append(dip)
    return np.array(strikes), np.array(dips)


def plot_stereonets(strikes, dips, strikes_sub, dips_sub, method, sigma, max_plot, output_name):
    # Create figure with two stereonets
    fig, (ax1, ax2) = plt.subplots(
        2, 1, figsize=(8, 12),
        subplot_kw={'projection': 'stereonet'}
    )
    # 1) Individual poles
    ax1.pole(strikes_sub, dips_sub, 'k.', ms=2)
    ax1.set_title('Individual poles')
    ax1.grid(True)
    # 2) Density contour
    dens = ax2.density_contourf(
        strikes, dips,
        measurement='poles',
        method=method,
        sigma=sigma
    )
    fig.colorbar(dens, ax=ax2, label='Pole density', pad=0.12)
    ax2.set_title('Density contour')
    ax2.grid(True)
    # Recalculate density grid to find max-density pole
    dgx, dgy, dgz = mplstereonet.density_grid(
        strikes, dips,
        measurement='poles',
        method=method,
        sigma=sigma
    )
    i_max, j_max = np.unravel_index(np.nanargmax(dgz), dgz.shape)
    max_rad_x = dgx[i_max, j_max]
    max_rad_y = dgy[i_max, j_max]
    max_strike, max_dip = mplstereonet.geographic2pole(max_rad_x, max_rad_y)
    # Mark max-density pole on both plots
    for ax in (ax1, ax2):
        ax.pole(max_strike, max_dip, 'ro', ms=5)
        ax.plane(max_strike, max_dip, 'r')
    st.write(f"Max-density pole: strike={max_strike:.1f}, dip={max_dip:.1f}")
    # Save if desired
    if output_name:
        fig.savefig(output_name, dpi=300)
        st.success(f"Saved figure to {output_name}")
    st.pyplot(fig)

# --- Streamlit UI ---
st.title('Structural Trend Application')

uploaded = st.file_uploader('Upload CSV file', type='csv')
if uploaded:
    skip_rows = st.number_input('Header rows to skip', min_value=0, step=1, value=0)
    separation_limit = st.number_input('Separation-distance limit', min_value=0.0, step=0.1, value=1.0)
    if st.button('Calculate planes'):
        df = pd.read_csv(uploaded, skiprows=skip_rows)
        if not set(['x','y','z']).issubset(df.columns):
            st.error("CSV must contain 'x','y','z' columns.")
        else:
            planes, colinear = calculate_planes(df[['x','y','z']].values, separation_limit)
            st.write(f"Valid planes: {len(planes)}, invalid/colinear: {len(colinear)}")
            strikes_all, dips_all = extract_strike_dip(planes)
            # Selection of subset
            use_all = st.radio('Use all planes?', ('Yes', 'No'))
            if use_all == 'Yes':
                strikes_sub, dips_sub = strikes_all, dips_all
            else:
                sample_method = st.selectbox('Subset method', ('Random subset', 'Slice'))
                if sample_method == 'Random subset':
                    size = st.number_input('Subset size', min_value=1, max_value=len(strikes_all), value=min(200, len(strikes_all)))
                    idx = np.random.choice(len(strikes_all), size, replace=False)
                    strikes_sub, dips_sub = strikes_all[idx], dips_all[idx]
                else:
                    start_idx = st.number_input('Slice start index', min_value=0, max_value=len(strikes_all)-1, value=0)
                    end_idx = st.number_input('Slice end index', min_value=1, max_value=len(strikes_all), value=len(strikes_all))
                    strikes_sub, dips_sub = strikes_all[start_idx:end_idx], dips_all[start_idx:end_idx]
            # Density parameters
            method = st.selectbox('Density method', ('exponential_kamb', 'linear_kamb', 'kamb', 'kernel', 'counts'))
            sigma = None
            if method in ('exponential_kamb', 'linear_kamb', 'kamb'):
                sigma = st.number_input('Sigma for Kamb', min_value=0.1, step=0.1, value=3.0)
            else:
                sigma = 0.0
            max_plot = st.number_input('Max # poles to plot', min_value=1, step=1, value=2000)
            output_name = st.text_input('Output image filename (jpg/png)', '')
            if st.button('Generate stereonets'):
                plot_stereonets(strikes_all, dips_all, strikes_sub, dips_sub, method, sigma, max_plot, output_name)